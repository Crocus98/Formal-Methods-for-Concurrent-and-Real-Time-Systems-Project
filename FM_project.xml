<?xml version="1.0" encoding="utf-8"?>
<!DOCTYPE nta PUBLIC '-//Uppaal Team//DTD Flat System 1.1//EN' 'http://www.it.uu.se/research/group/darts/uppaal/flat-1_2.dtd'>
<nta>
	<declaration>//SIMPLE SETTINGS
//Train settings
const int NUM_TRAINS = 3;
const int RECHARGING_MULTIPLIER = 3;
const int SPEED[NUM_TRAINS] = {7,10,8};
const int MAX_CHARGE[NUM_TRAINS] = {30,35,28}; //time
const int INITIAL_CHARGE[NUM_TRAINS] ={28,30,25}; //must be less than MAX_CHARGE
const int INITIAL_STATION[NUM_TRAINS] = {0,0,2};
const int T_LINES[NUM_TRAINS] = {0,0,0};
const int NEXT_STATION[NUM_TRAINS] = {1,1,1}; //must be inside the line


//Station settings
const int NUM_STATIONS = 3;
const int SPARE_TIME = 6;
const int MAX_TRACKS[NUM_STATIONS] = {2,2,1};
const int PASSENGERS_TIME = 3;
const int REQUEST_DELAY = 2;
int TRAINS_INSIDE[NUM_STATIONS] = {2,0,1};
int ENTERING_QUEUE [NUM_STATIONS][NUM_TRAINS] = {{-1,-1,-1},
                                                {-1,-1,-1},
                                                {-1,-1,-1}};
int BUSY_STATIONS [NUM_STATIONS] = {0,0,0};
int URGENT_STATIONS [NUM_STATIONS] = {0,0,0};
int URGENT_QUEUE [NUM_STATIONS][NUM_TRAINS] = {{-1,-1,-1},
                                                {-1,-1,-1},
                                                {-1,-1,-1}};

//Railways settins
const int NUM_LINES = 2;
const int NUM_MAX_STATIONS_LINE = 3;
const int LINES[NUM_LINES][NUM_MAX_STATIONS_LINE] = {{0,1,2},{0,1,-1}}; //0,1,2
const int DISTANCES [NUM_STATIONS][NUM_STATIONS] ={{0,70,-1},
                                                   {70,0,50},
                                                   {-1,50,0}};
const int MAX_DELAYS [NUM_STATIONS][NUM_STATIONS] ={{0,40,-1},
                                                    {40,0,36},
                                                    {-1,36,0}};




/*
//COMPLETE SETTINGS
//Train settings
const int NUM_TRAINS = 7;
const int RECHARGING_MULTIPLIER = 10;
const int SPEED[NUM_TRAINS] = {15,15,15,15,15,15,15};
const int MAX_CHARGE[NUM_TRAINS] = {30, 32, 32, 28, 24, 18, 35}; //time
const int INITIAL_CHARGE[NUM_TRAINS] ={28,28,32,25,24,18,30}; //must be less than MAX_CHARGE
const int INITIAL_STATION[NUM_TRAINS] = {0,3,0,4,4,3,0}; //the station where the train starts
const int T_LINES[NUM_TRAINS] = {1,2,0,2,1,0,1}; //the line the train follows
const int NEXT_STATION[NUM_TRAINS] = {1,2,1,2,2,2,1}; //must be inside the line


//Station settings
const int NUM_STATIONS = 5;
const int SPARE_TIME = 6;
const int MAX_TRACKS[NUM_STATIONS] = {3,2,2,2,3}; //{4,2,2,3,4};
const int PASSENGERS_TIME = 3;
const int REQUEST_DELAY = 2;
int TRAINS_INSIDE[NUM_STATIONS] = {3,0,0,2,2};
int ENTERING_QUEUE [NUM_STATIONS][NUM_TRAINS] = {{-1,-1,-1,-1,-1,-1,-1},
                                                {-1,-1,-1,-1,-1,-1,-1},
                                                {-1,-1,-1,-1,-1,-1,-1},
                                                {-1,-1,-1,-1,-1,-1,-1},
                                                {-1,-1,-1,-1,-1,-1,-1}};
                                                

//Railways settins
const int NUM_LINES = 3;
const int NUM_MAX_STATIONS_LINE = 4;
const int LINES [NUM_LINES][NUM_MAX_STATIONS_LINE] = {{0,1,2,3},{0,1,2,4},{3,2,4,-1}}; //0,1,2
const int DISTANCES [NUM_STATIONS][NUM_STATIONS] ={{0,70,-1,-1,-1},
                                                     {70,0,50,-1,-1},
                                                     {-1,50,0,60,80},
                                                     {-1,-1,60,0,-1},
                                                     {-1,-1,80,-1,0}};
const int MAX_DELAYS [NUM_STATIONS][NUM_STATIONS] ={{0,1000,-1,-1,-1},
                                                     {1000,0,1000,-1,-1},
                                                     {-1,1000,0,1000,1000},
                                                     {-1,-1,1000,0,-1},
                                                     {-1,-1,1000,-1,0}};
*/


//Channels
chan enter_station_request[NUM_STATIONS][NUM_TRAINS];
chan enter_station_reply_ok[NUM_TRAINS];
broadcast chan enter_station_reply_ko[NUM_TRAINS];
chan exit_station[NUM_STATIONS];


//Global functions
bool authorization_granted(int station){
    if(TRAINS_INSIDE[station] &lt; MAX_TRACKS[station]){
        return true;
    }
    else{
        return false;
    }
}
</declaration>
	<template>
		<name x="5" y="5">Train</name>
		<parameter>const int [0,NUM_TRAINS-1] id_train, int charge, const int max_charge, const int speed,  int current_station, const int line, int next_station</parameter>
		<declaration>clock mov_time;
clock waiting_time;
clock temp_mov_time;

//Functions
int get_maximal_delay(){
    return MAX_DELAYS[current_station][next_station];
}

int compute_minimal_charge (){
    int max_delay_charge = get_maximal_delay();
    if(max_delay_charge &gt; max_charge){
        return max_charge;
    }
    return max_delay_charge;
}

int compute_minimal_travel_time (){
    int minimal_travel_time = DISTANCES[current_station][next_station];
    for (number : int[0, 1000]){
        minimal_travel_time -= SPEED[id_train];
        if(minimal_travel_time &lt;=0){
            return number;
        }
    }
    return 0;
}

int get_minimal_recharge_time (){
    if (compute_minimal_charge() &gt; charge + PASSENGERS_TIME * RECHARGING_MULTIPLIER){
        int minimal_charge = compute_minimal_charge() - charge;
        for (number : int[0, 1000]){
            minimal_charge -= RECHARGING_MULTIPLIER;
            if(minimal_charge &lt;=0){
                return number;
            }
        }
    }
    return PASSENGERS_TIME;
}

int max_time_before_leaving(){
    return get_maximal_delay() - SPARE_TIME - compute_minimal_travel_time();
}

void decrease_charge(int dec){
    charge -= dec;
    if(charge &lt;= 0){
        charge = 0;
    }
}

void increase_charge(int time_inc){
    charge += (RECHARGING_MULTIPLIER * time_inc);
    if(charge &gt; max_charge){
        charge = max_charge;
    }
}


void enqueue(){
    for(i : int[0, NUM_TRAINS-1]){
        if(ENTERING_QUEUE[next_station][i]==-1){
            ENTERING_QUEUE[next_station][i] = id_train;
            return ;
        }
    }
}

bool enter_permission(){
    if(ENTERING_QUEUE[current_station][0]==id_train &amp;&amp; authorization_granted(current_station)){
        return true;
    }
    return false;
}

void dequeue(){
    for(i : int[0, NUM_TRAINS-2]){
        if(ENTERING_QUEUE[next_station][i+1]!=-1){
            ENTERING_QUEUE[next_station][i] = ENTERING_QUEUE[next_station][i+1];
            if(i+1 == NUM_TRAINS-1){
                ENTERING_QUEUE[next_station][i+1] = -1;
            }
        }
        else{
            ENTERING_QUEUE[next_station][i] = -1;
        }
    }
}


void urgent_enqueue(){
    for(i : int[0, NUM_TRAINS-1]){
        if(URGENT_QUEUE[next_station][i]==-1){
            URGENT_QUEUE[next_station][i] = id_train;
            return ;
        }
    }
}

void need_urgent(){
    URGENT_STATIONS [next_station] = 1;
}

void update_train_info(){
    int next_index = 0;
    for (current_index : int[0, NUM_MAX_STATIONS_LINE-1])
    {
        if(LINES[line][current_index] == current_station){ //current index found
            current_station = next_station; //new current station found
            next_index = current_index;
            if(next_index-1 &lt; 0 || LINES[line][next_index-1] == -1){
                next_index = next_index + 1;
            }
            else if(next_index+1 &gt; NUM_MAX_STATIONS_LINE-1 || LINES[line][next_index+1] == -1){
                next_index = next_index - 1;
            }
            else{
                if(LINES[line][next_index+1] == next_station){
                    next_index = next_index+1;
                }
                else if(LINES[line][next_index-1] == next_station){
                    next_index = next_index-1;
                }
            }
            if(current_index &lt; next_index){
                if(next_index+1 &gt; NUM_MAX_STATIONS_LINE-1 || LINES[line][next_index+1]== -1)
                {
                    next_index = next_index - 1;
                }
                else
                {
                    next_index = next_index + 1;
                }
            }
            else if(next_index -1 &lt; 0 || LINES[line][next_index-1]== -1)
            {
                next_index +=1;
            }
            else
            {
                next_index -=1;
            }
            next_station = LINES[line][next_index];
            return;
        }
    }
    return;
}</declaration>
		<location id="id0" x="-1615" y="-697">
			<name x="-1692" y="-740">Charging</name>
			<label kind="invariant" x="-1938" y="-705">waiting_time &lt;= get_minimal_recharge_time()</label>
		</location>
		<location id="id1" x="-1615" y="-502">
			<name x="-1709" y="-502">Overcharging</name>
			<label kind="invariant" x="-1734" y="-484">waiting_time &lt;= 1</label>
		</location>
		<location id="id2" x="-756" y="-501">
			<name x="-816" y="-501">Moving</name>
			<label kind="invariant" x="-739" y="-510">temp_mov_time &lt;= compute_minimal_travel_time()</label>
		</location>
		<location id="id3" x="-756" y="-697">
			<name x="-816" y="-688">Waiting</name>
			<label kind="invariant" x="-867" y="-671">waiting_time &lt;= 1</label>
		</location>
		<location id="id4" x="-756" y="-901">
			<name x="-833" y="-935">Waiting_Request_Delay</name>
			<label kind="invariant" x="-994" y="-918">waiting_time &lt;= REQUEST_DELAY</label>
		</location>
		<location id="id5" x="-1615" y="-885">
			<name x="-1641" y="-919">Initializer</name>
		</location>
		<location id="id6" x="-578" y="-1054">
			<name x="-603" y="-1088">ERROR</name>
		</location>
		<init ref="id5"/>
		<transition>
			<source ref="id1"/>
			<target ref="id2"/>
			<label kind="guard" x="-1198" y="-527">enter_permission()</label>
		</transition>
		<transition>
			<source ref="id4"/>
			<target ref="id6"/>
			<label kind="guard" x="-977" y="-1079">mov_time &gt; get_maximal_delay() || charge &lt;= 0</label>
			<nail x="-756" y="-1054"/>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id6"/>
			<label kind="guard" x="-518" y="-1079">mov_time &gt; get_maximal_delay() || charge &lt;= 0</label>
			<nail x="-399" y="-739"/>
			<nail x="-399" y="-1054"/>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id0"/>
			<label kind="synchronisation" x="-1479" y="-756">enter_station_reply_ok[id_train]?</label>
			<label kind="assignment" x="-1479" y="-739">mov_time = 0, waiting_time = 0, decrease_charge(1),
update_train_info()</label>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id3"/>
			<label kind="guard" x="-578" y="-705">waiting_time &gt;= 1</label>
			<label kind="assignment" x="-578" y="-688">waiting_time = 0, decrease_charge(1)</label>
			<nail x="-586" y="-697"/>
			<nail x="-586" y="-637"/>
		</transition>
		<transition>
			<source ref="id5"/>
			<target ref="id0"/>
			<label kind="assignment" x="-1810" y="-816">waiting_time=0, mov_time=0</label>
		</transition>
		<transition>
			<source ref="id4"/>
			<target ref="id3"/>
			<label kind="guard" x="-1011" y="-833">waiting_time &gt;= REQUEST_DELAY-1</label>
			<label kind="assignment" x="-1011" y="-816">decrease_charge(REQUEST_DELAY), 
waiting_time = 0, need_urgent()</label>
		</transition>
		<transition>
			<source ref="id3"/>
			<target ref="id4"/>
			<label kind="synchronisation" x="-671" y="-841">enter_station_reply_ko[id_train]?</label>
			<label kind="assignment" x="-671" y="-824">waiting_time = 0, urgent_enqueue()</label>
			<nail x="-680" y="-739"/>
			<nail x="-680" y="-901"/>
		</transition>
		<transition>
			<source ref="id2"/>
			<target ref="id3"/>
			<label kind="guard" x="-748" y="-603">temp_mov_time &gt;= compute_minimal_travel_time()</label>
			<label kind="assignment" x="-748" y="-586">decrease_charge(compute_minimal_travel_time()), enqueue(), waiting_time = 0</label>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id2"/>
			<label kind="guard" x="-1530" y="-340">charge == max_charge || mov_time &gt;=max_time_before_leaving()</label>
			<label kind="synchronisation" x="-1530" y="-323">exit_station[current_station]!</label>
			<label kind="assignment" x="-1530" y="-306">temp_mov_time=0</label>
			<nail x="-1615" y="-341"/>
			<nail x="-756" y="-340"/>
		</transition>
		<transition>
			<source ref="id1"/>
			<target ref="id1"/>
			<label kind="guard" x="-2159" y="-501">waiting_time &gt;=1 &amp;&amp; mov_time &lt; max_time_before_leaving()</label>
			<label kind="assignment" x="-2159" y="-484">increase_charge(1), waiting_time = 0</label>
			<nail x="-1870" y="-502"/>
			<nail x="-1870" y="-570"/>
		</transition>
		<transition>
			<source ref="id0"/>
			<target ref="id1"/>
			<label kind="assignment" x="-1938" y="-637">increase_charge(get_minimal_recharge_time()), 
waiting_time = 0</label>
		</transition>
	</template>
	<template>
		<name>Station</name>
		<parameter>const int[0,NUM_STATIONS-1] id_station</parameter>
		<declaration>//Station variables
bool kick_trains_asap = false;
int temp_train = -1;

//Station functions
bool trains_entering (){
    if(ENTERING_QUEUE[id_station][0] == -1){
        return false;
    }
    else{
        return true;
    }
}

int count_entering_trains(){
    int temp = 0;
    for(i : int[0, NUM_TRAINS-1]){
        if(ENTERING_QUEUE[id_station][i]==-1){
            return temp;
        }
        else{
            temp +=1;
        }
    }
    return temp;
}

bool check_situation (){
    if(MAX_TRACKS[id_station] &gt; TRAINS_INSIDE[id_station]){
        return true;
    }
    return false;
}

void urgent_dequeue(){
    for(i : int[0, NUM_TRAINS-2]){
        if(URGENT_QUEUE[id_station][i+1]!=-1){
            URGENT_QUEUE[id_station][i] = URGENT_QUEUE[id_station][i+1];
            if(i+1 == NUM_TRAINS-1){
                URGENT_QUEUE[id_station][i+1] = -1;
            }
        }
        else{
            URGENT_QUEUE[id_station][i] = -1;
        }
    }
    if(URGENT_QUEUE[id_station][0] == -1){
        URGENT_STATIONS[id_station] = 0;
    }
}

void dequeue(){
    if(URGENT_STATIONS[id_station] == 1){
        urgent_dequeue();
    }else{
        for(i : int[0, NUM_TRAINS-2]){
            if(ENTERING_QUEUE[id_station][i+1]!=-1){
                ENTERING_QUEUE[id_station][i] = ENTERING_QUEUE[id_station][i+1];
                if(i+1 == NUM_TRAINS-1){
                    ENTERING_QUEUE[id_station][i+1] = -1;
                }
            }
            else{
                ENTERING_QUEUE[id_station][i] = -1;
            }
        }
    }
}


void busy(){
    BUSY_STATIONS[id_station] = 1;
}

void not_busy(){
    BUSY_STATIONS[id_station] = 0;
}


void increase_inside_count(){
    TRAINS_INSIDE[id_station] += 1;
}</declaration>
		<location id="id7" x="-9724" y="-9477">
		</location>
		<location id="id8" x="-9418" y="-9129">
			<urgent/>
		</location>
		<init ref="id7"/>
		<transition>
			<source ref="id8"/>
			<target ref="id7"/>
			<label kind="guard" x="-9410" y="-9443">not check_situation()</label>
			<label kind="synchronisation" x="-9410" y="-9426">enter_station_reply_ko[temp_train]!</label>
			<label kind="assignment" x="-9410" y="-9409">dequeue(), not_busy()</label>
			<nail x="-9418" y="-9477"/>
		</transition>
		<transition>
			<source ref="id8"/>
			<target ref="id7"/>
			<label kind="guard" x="-9699" y="-9316">check_situation()</label>
			<label kind="synchronisation" x="-9699" y="-9299">enter_station_reply_ok[temp_train]!</label>
			<label kind="assignment" x="-9699" y="-9282">dequeue(), not_busy(), increase_inside_count()</label>
		</transition>
		<transition>
			<source ref="id7"/>
			<target ref="id8"/>
			<label kind="select" x="-9920" y="-9222">train: int[0, NUM_TRAINS-1]</label>
			<label kind="synchronisation" x="-10005" y="-9205">enter_station_request[id_station][train]?</label>
			<label kind="assignment" x="-9903" y="-9188">temp_train = train, busy()</label>
			<nail x="-9724" y="-9129"/>
		</transition>
	</template>
	<template>
		<name>Controller</name>
		<parameter>const int[0,NUM_STATIONS-1] id_station</parameter>
		<declaration>bool entering_access(){
    if(ENTERING_QUEUE [id_station][0] &gt; -1){
        return true;
    }
    return false;
}

void dequeue(){
    for(i : int[0, NUM_TRAINS-2]){
        if(ENTERING_QUEUE[id_station][i+1]!=-1){
            ENTERING_QUEUE[id_station][i] = ENTERING_QUEUE[id_station][i+1];
            if(i+1 == NUM_TRAINS-1){
                ENTERING_QUEUE[id_station][i+1] = -1;
            }
        }
        else{
            ENTERING_QUEUE[id_station][i] = -1;
        }
    }
}

bool station_free(){
    if(BUSY_STATIONS[id_station] == 0){
        return true;
    }
    return false;
}

bool urgent_station(){
    if(URGENT_STATIONS[id_station] == 1){
        return true;
    }
    return false;
}

void decrease_inside_count(){
    TRAINS_INSIDE[id_station] -= 1;
}</declaration>
		<location id="id9" x="-229" y="-102">
			<name x="-263" y="-136">Idle</name>
		</location>
		<init ref="id9"/>
		<transition>
			<source ref="id9"/>
			<target ref="id9"/>
			<label kind="guard" x="-238" y="-246">urgent_station() &amp;&amp; station_free() &amp;&amp; URGENT_QUEUE[id_station][0] &gt;=0</label>
			<label kind="synchronisation" x="-204" y="-229">enter_station_request[id_station][URGENT_QUEUE[id_station][0]]!</label>
			<nail x="-255" y="-229"/>
			<nail x="-119" y="-187"/>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id9"/>
			<label kind="guard" x="-119" y="-59">entering_access() &amp;&amp; station_free() &amp;&amp; not urgent_station()</label>
			<label kind="synchronisation" x="-127" y="-42">enter_station_request[id_station][ENTERING_QUEUE [id_station][0]]!</label>
			<nail x="-93" y="-93"/>
			<nail x="-161" y="17"/>
		</transition>
		<transition>
			<source ref="id9"/>
			<target ref="id9"/>
			<label kind="synchronisation" x="-518" y="-102">exit_station[id_station]?</label>
			<label kind="assignment" x="-510" y="-85">decrease_inside_count()</label>
			<nail x="-323" y="-25"/>
			<nail x="-357" y="-144"/>
		</transition>
	</template>
	<system>
//SIMPLE SETTINGS
//id_train, charge, max_charge, speed, current_station, line, next_station
train_0 = Train (0, INITIAL_CHARGE[0], MAX_CHARGE[0], SPEED[0], INITIAL_STATION[0], T_LINES[0], NEXT_STATION[0]);
train_1 = Train (1, INITIAL_CHARGE[1], MAX_CHARGE[1], SPEED[1], INITIAL_STATION[1], T_LINES[1], NEXT_STATION[1]);
train_2 = Train (2, INITIAL_CHARGE[2], MAX_CHARGE[2], SPEED[2], INITIAL_STATION[2], T_LINES[2], NEXT_STATION[2]);

//id_station, max_tracks
station_0 = Station(0);
station_1 = Station(1);
station_2 = Station(2);

//id_station
controller_0 = Controller(0);
controller_1 = Controller(1);
controller_2 = Controller(2);

// List one or more processes to be composed into a system.
system train_0, train_1, train_2, station_0, station_1, station_2, controller_0, controller_1, controller_2;

/*
//COMPLETE SETTINGS
//id_train, charge, max_charge, speed, current_station, line, next_station
train_0 = Train (0, INITIAL_CHARGE[0], MAX_CHARGE[0], SPEED[0], INITIAL_STATION[0], T_LINES[0], NEXT_STATION[0]);
train_1 = Train (1, INITIAL_CHARGE[1], MAX_CHARGE[1], SPEED[1], INITIAL_STATION[1], T_LINES[1], NEXT_STATION[1]);
train_2 = Train (2, INITIAL_CHARGE[2], MAX_CHARGE[2], SPEED[2], INITIAL_STATION[2], T_LINES[2], NEXT_STATION[2]);
train_3 = Train (3, INITIAL_CHARGE[3], MAX_CHARGE[3], SPEED[3], INITIAL_STATION[3], T_LINES[3], NEXT_STATION[3]);
train_4 = Train (4, INITIAL_CHARGE[4], MAX_CHARGE[4], SPEED[4], INITIAL_STATION[4], T_LINES[4], NEXT_STATION[4]);
train_5 = Train (5, INITIAL_CHARGE[5], MAX_CHARGE[5], SPEED[5], INITIAL_STATION[5], T_LINES[5], NEXT_STATION[5]);
train_6 = Train (6, INITIAL_CHARGE[6], MAX_CHARGE[6], SPEED[6], INITIAL_STATION[6], T_LINES[6], NEXT_STATION[6]);

//id_station, max_tracks
station_0 = Station(0);
station_1 = Station(1);
station_2 = Station(2);
station_3 = Station(3);
station_4 = Station(4);

// List one or more processes to be composed into a system.
system train_0, train_1, train_2, train_3, train_4, train_5, train_6, station_0, station_1, station_2, station_3, station_4;
*/</system>
	<queries>
		<query>
			<formula>A[] not deadlock</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] ( TRAINS_INSIDE[station_4.id_station] &lt;= MAX_TRACKS[station_4.id_station] )</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] ( TRAINS_INSIDE[station_3.id_station] &lt;= MAX_TRACKS[station_3.id_station] )</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] ( TRAINS_INSIDE[station_2.id_station] &lt;= MAX_TRACKS[station_2.id_station] )</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] ( TRAINS_INSIDE[station_1.id_station] &lt;= MAX_TRACKS[station_1.id_station] )</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] ( TRAINS_INSIDE[station_0.id_station] &lt;= MAX_TRACKS[station_0.id_station] )</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] ( train_6.mov_time &lt;= MAX_DELAYS[train_6.current_station][train_6.next_station] )</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] ( train_5.mov_time &lt;= MAX_DELAYS[train_5.current_station][train_5.next_station] )</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] ( train_4.mov_time &lt;= MAX_DELAYS[train_4.current_station][train_4.next_station] )</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] ( train_3.mov_time &lt;= MAX_DELAYS[train_3.current_station][train_3.next_station] )</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] ( train_2.mov_time &lt;= MAX_DELAYS[train_2.current_station][train_2.next_station] )</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] ( train_1.mov_time &lt;= MAX_DELAYS[train_1.current_station][train_1.next_station] )</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] ( train_0.mov_time &lt;= MAX_DELAYS[train_0.current_station][train_0.next_station] )</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] ( train_6.charge &gt; 0 )</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] ( train_5.charge &gt; 0 )</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] ( train_4.charge &gt; 0 )</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] ( train_3.charge &gt; 0 )</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] ( train_2.charge &gt; 0 )</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] ( train_1.charge &gt; 0 )</formula>
			<comment></comment>
		</query>
		<query>
			<formula>A[] ( train_0.charge &gt; 0 )</formula>
			<comment></comment>
		</query>
	</queries>
</nta>
